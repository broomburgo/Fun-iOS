<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Fun iOS</title>
    <link>https://broomburgo.github.io/fun-ios/post/</link>
    <description>Recent content in Posts on Fun iOS</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; &lt;a href=&#34;https://github.com/broomburgo&#34;&gt;Elviro Rocca&lt;/a&gt; 2018</copyright>
    <lastBuildDate>Mon, 30 Jul 2018 15:00:00 +0200</lastBuildDate>
    
	<atom:link href="https://broomburgo.github.io/fun-ios/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Why Monads?</title>
      <link>https://broomburgo.github.io/fun-ios/post/why-monads/</link>
      <pubDate>Mon, 30 Jul 2018 15:00:00 +0200</pubDate>
      
      <guid>https://broomburgo.github.io/fun-ios/post/why-monads/</guid>
      <description>There&amp;rsquo;s some talk going on in the Swift Forums about whether it could be useful or not to add the notion of Higher-Kinded Types (from now on, HKTs) to the Swift&amp;rsquo;s type system. This discussion has been going for a while in the Swift community, and there seems to be a lack of practical examples to sustain the need for such an advanced feature. Unfortunately, HKTs are in the area of things that become obvious if you have them and use them every day, but tend to remain obscure if you have to work without them: that&amp;rsquo;s because HKTs can shift one&amp;rsquo;s way of thinking about programming, abstractions and computation in general.</description>
    </item>
    
    <item>
      <title>Algebraic data types for contextual and conditional computation</title>
      <link>https://broomburgo.github.io/fun-ios/post/algebraic-datatypes-for-contextual-and-conditional-computation/</link>
      <pubDate>Mon, 19 Mar 2018 15:00:01 +0100</pubDate>
      
      <guid>https://broomburgo.github.io/fun-ios/post/algebraic-datatypes-for-contextual-and-conditional-computation/</guid>
      <description>An algebraic data type (ADT from now on) is a type (class, struct, enum, whatever the language allows us) that has no intrinsic semantics, and only exists for combining two or more other types in a specific way.
For example, in Swift the tuple (Int,String) is an ADT, in the sense that the only information it conveys is the fact that one instance of it will contain one instance of Int and one instance of String.</description>
    </item>
    
    <item>
      <title>Lenses and Prisms in Swift: a pragmatic approach</title>
      <link>https://broomburgo.github.io/fun-ios/post/lenses-and-prisms-in-swift-a-pragmatic-approach/</link>
      <pubDate>Sun, 19 Nov 2017 14:00:01 +0100</pubDate>
      
      <guid>https://broomburgo.github.io/fun-ios/post/lenses-and-prisms-in-swift-a-pragmatic-approach/</guid>
      <description>This is a new version of an old article about lenses and prisms in Swift. This one contains many updates and more precisely reflects how I actually use these things in my work. This is also based on a talk I gave at iOSDevUK 2017 and Mobilization Conference 2017. I&amp;rsquo;m keeping the old article in draft as reference.
 The concept of functional lens has become pretty popular in functional programming circles, and there are already good contributions for applying lenses to other, traditionally imperative/OO contexts, like Javascript.</description>
    </item>
    
    <item>
      <title>On Abstraction</title>
      <link>https://broomburgo.github.io/fun-ios/post/on-abstraction/</link>
      <pubDate>Sat, 09 Sep 2017 20:10:00 +0000</pubDate>
      
      <guid>https://broomburgo.github.io/fun-ios/post/on-abstraction/</guid>
      <description>This post is a direct answer to this other post, which itself is mostly an answer to a bunch of discussions on Twitter, talks and more posts. While this post has probably value by itself, it&amp;rsquo;s probably better to read the original post first, because I&amp;rsquo;m going to refer to some of its statements.
 There&amp;rsquo;s an interesting discussion going in the functional Swift community: whether using abstract data types, like Monoid, is actually useful, and how this relates to the way protocols are usually laid out in the standard library.</description>
    </item>
    
  </channel>
</rss>